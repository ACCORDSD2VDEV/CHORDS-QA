---
output:  
    word_document :
        reference_docx: QaTableStyle6.docx
        toc: yes
params: 
    DBServerName: 
        label: "Database Server Name:"
        input: text
        value: ""
        placeholder: "Enter your VDW Database Server Name"
    DBPort: 
        label: "Database Server Port:"
        input: text
        value: ""
        placeholder: "Enter the database port if required.  Leave blank for default."
    DBName:
        label: "Database Name:"
        input: text
        value: ""
        placeholder: "Enter your VDW Database Name"
    DBUser:
        label: "Database User Name"
        input: text
        value: ""
        placeholder: "leave blank if using windows authentication for your server"
    DBPassword:
        label: "Database Password"
        input: password
        value: ""
        placeholder: "leave blank if using windows authentication for your server"
    QAAlert:
        label: "Create Alert List in Output"
        value: TRUE
---

```{r setup, include=FALSE}
library(RODBC)
library(knitr)
library(tidyverse)
knitr::opts_chunk$set(echo = TRUE,
                message = FALSE,
                warning = FALSE)
startTime <- Sys.time()
# connection to sql server
if (nchar(params$DBUser) == 0)
{
	con <- DBI::dbConnect(odbc::odbc(),
                      Driver = "SQL Server",
                      Server = params$DBServerName,
                      Database = params$DBName,
                      Port = params$DBPort)
	sqldb <- odbcDriverConnect(paste('driver={SQL Server};server=',params$DBServerName,ifelse(nchar(params$DBPort) > 0, paste(",",params$DBPort, sep=""), ""),';database=',params$DBName, sep=""), readOnlyOptimize = TRUE)
} else {
	con <- DBI::dbConnect(odbc::odbc(),
                      Driver = "SQL Server",
                      Server = params$DBServerName,
                      Database = params$DBName,
                      Port = params$DBPort,
                      UID = params$DBUser,
                      PWD = params$DBPassword)
	sqldb <- odbcDriverConnect(paste('driver={SQL Server};uid=',params$DBUser,';pwd=',params$DBPassword,';server=',params$DBServerName, ifelse(nchar(params$DBPort) > 0, paste(",",params$DBPort, sep=""), ""),';database=',params$DBName, sep=""), readOnlyOptimize = TRUE)
}
#Checks to see if partner is using table replacements.
#Checks if the CHORDS_TableNames table exists in their VDW.  If not, check if they are using a csv.  If not, applies default table names.
dfChordsTbls <- odbc::dbGetQuery(con, "                    
    IF EXISTS
    (
        SELECT
            *
        FROM  SYSOBJECTS
        WHERE XTYPE = 'U' AND
              NAME = 'CHORDS_TableNames'
    )
    BEGIN
        SELECT
            [ORG_NAME],
            [NEW_NAME]
        FROM[CHORDS_TABLENAMES];
    END; ")
if (nrow(dfChordsTbls) == 0  && exists("outputdir")){
  tableReplaceFile <-  paste0(outputdir, "\\tablereplace.csv")
  if (file.exists(tableReplaceFile)){
    print("updating for QA using tablereplace.csv")
    dfChordsTbls <- read.csv2(tableReplaces, header = TRUE, sep = ",", stringsAsFactors=FALSE)
  }
}
if (nrow(dfChordsTbls) > 0){
  lab_results <- ifelse("lab_results" %in% tolower(dfChordsTbls$ORG_NAME),  dfChordsTbls$NEW_NAME[match(tolower("lab_results"), tolower(dfChordsTbls$ORG_NAME))], "lab_results")
  encounters <- ifelse("encounters" %in% tolower(dfChordsTbls$ORG_NAME),  dfChordsTbls$NEW_NAME[match(tolower("encounters"), tolower(dfChordsTbls$ORG_NAME))], "encounters")
  prescribing <- ifelse("prescribing" %in% tolower(dfChordsTbls$ORG_NAME),  dfChordsTbls$NEW_NAME[match(tolower("prescribing"), tolower(dfChordsTbls$ORG_NAME))], "prescribing")
  procedures <- ifelse("procedures" %in% tolower(dfChordsTbls$ORG_NAME),  dfChordsTbls$NEW_NAME[match(tolower("procedures"), tolower(dfChordsTbls$ORG_NAME))], "procedures")
  social_history <- ifelse("social_history" %in% tolower(dfChordsTbls$ORG_NAME),  dfChordsTbls$NEW_NAME[match(tolower("social_history"), tolower(dfChordsTbls$ORG_NAME))], "social_history")
  provider_specialty <- ifelse("provider_specialty" %in% tolower(dfChordsTbls$ORG_NAME),  dfChordsTbls$NEW_NAME[match(tolower("provider_specialty"), tolower(dfChordsTbls$ORG_NAME))], "provider_specialty")
  diagnoses <- ifelse("diagnoses" %in% tolower(dfChordsTbls$ORG_NAME),  dfChordsTbls$NEW_NAME[match(tolower("diagnoses"), tolower(dfChordsTbls$ORG_NAME))], "diagnoses")
  vital_signs <- ifelse("vital_signs" %in% tolower(dfChordsTbls$ORG_NAME),  dfChordsTbls$NEW_NAME[match(tolower("vital_signs"), tolower(dfChordsTbls$ORG_NAME))], "vital_signs")
  census_location <- ifelse("census_location" %in% tolower(dfChordsTbls$ORG_NAME),  dfChordsTbls$NEW_NAME[match(tolower("census_location"), tolower(dfChordsTbls$ORG_NAME))], "census_location")
  demographics <- ifelse("demographics" %in% tolower(dfChordsTbls$ORG_NAME),  dfChordsTbls$NEW_NAME[match(tolower("demographics"), tolower(dfChordsTbls$ORG_NAME))], "demographics")
  pro_surveys <- ifelse("pro_surveys" %in% tolower(dfChordsTbls$ORG_NAME),  dfChordsTbls$NEW_NAME[match(tolower("pro_surveys"), tolower(dfChordsTbls$ORG_NAME))], "pro_surveys")
  pro_questions <- ifelse("pro_questions" %in% tolower(dfChordsTbls$ORG_NAME),  dfChordsTbls$NEW_NAME[match(tolower("pro_questions"), tolower(dfChordsTbls$ORG_NAME))], "pro_questions")
  pro_responses <- ifelse("pro_responses" %in% tolower(dfChordsTbls$ORG_NAME),  dfChordsTbls$NEW_NAME[match(tolower("pro_responses"), tolower(dfChordsTbls$ORG_NAME))], "pro_responses")
  
} else {
  # Names of database tables
  lab_results    <- "LAB_RESULTS"
  encounters      <- "ENCOUNTERS"
  prescribing <- "PRESCRIBING"
  procedures     <- "PROCEDURES"
  social_history  <- "SOCIAL_HISTORY"
  provider_specialty <- "PROVIDER_SPECIALTY"
  diagnoses <- "DIAGNOSES"
  vital_signs <- "VITAL_SIGNS"
  census_location <- "CENSUS_LOCATION"
  demographics <- "DEMOGRAPHICS"
  pro_surveys <- "PRO_SURVEYS"
  pro_questions <- "PRO_QUESTIONS"
  pro_responses <- "PRO_RESPONSES"
  
}
```

## CHORDS QA Report: VDW P2 Tables

The purpose of the data quality program is to characterize the data in a second set of CHORDS VDW tables (previously referred to as Priority 2 or "P2" tables).  The P2 tables include the following: LAB_RESULTS, PRESCRIBING, PROCEDURES, PROVIDER_SPECIALTY, SOCIAL_HISTORY, PRO_SURVEYS, and PRO_QUESTIONS. The program uses a series of SQL queries operationalized using RStudio to produce this report.  These tables provide descriptive information about data stored in a data partner's VDW and can be used to assess data model conformance, data plausibility, and data completeness.

This data quality report was generated from CHORDS `r params$DBName`.

## Information about the QA program 
Data Partner: 
Analyst: 
Query Run Date:  `r Sys.Date()`

## Data Check 1.01: Required tables are not present


## Data Check 1.02: Required tables are not populated


## Data Check 1.03: Required fields are not present


## Data Check 1.04: Required fields do not conform to data model specifications for data type, length, or name


## Data Check 1.05: Tables have primary key definition errors


## Data Check 1.06: Required fields contain values outside of data model specifications


## Data Check 1.07: Required fields have non-permissible missing values


## Data Check 1.08: Tables contain orphan PERSON_IDs 


## Data Check 1.09: Tables contain orphan ENCOUNTER_IDs 


## Data Check 1.10: Replication errors between the ENCOUNTER, PROCEDURES and DIAGNOSIS tables 


## Data Check 1.11: More than 5% of encounters are assigned to more than one patient 


## Data Check 1.12: Tables contain orphan PROVIDER_IDs


## Data Check 1.13: More than 5% of ICD, CPT, LOINC, RXCUI, or NDC codes do not conform to the expected length or content


## Data Check 2.01: More than 5% of records have future dates


## Data Check 2.02: More than 10% of records fall into the lowest or highest categories of age, height, weight, diastolic
## blood pressure, systolic blood pressure, or dispensed days supply


## Data Check 2.03: More than 5% of patients have illogical date relationships


## Data Check 3.03: More than 10% of records have missing or unknown values for the following fields:



## Data Check 3.04: Less than 50% of patients with encounters have DIAGNOSIS records 


## Data Check 3.05: Less than 50% of patients with encounters have PROCEDURES records 


## Data Check 3.06: More than 10% of IP (inpatient) or ED to inpatient (EI) encounters with any diagnosis don't have a principal
## diagnosis


## Data Check 3.07: Encounters, diagnoses, or procedures in an ambulatory (AV), emergency department (ED), ED to inpatient
## (EI), or inpatient (IP) setting are less than 75% complete three months prior to the current month



## Data Check 3.11: Vital, prescribing, or laboratory records are less than 75% complete three months prior to the current month


####Total program run time:
```{r calc_runtime}
# close odbc
odbc::dbDisconnect(con)
odbcCloseAll()
endTime <- Sys.time()
runtime <- endTime - startTime 
```


Query run time = `r runtime` minutes
